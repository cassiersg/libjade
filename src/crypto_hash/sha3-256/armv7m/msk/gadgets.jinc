require "masked_constants.jinc"

// The PRM4_masked code used fully dynamic gadgets with runtime number of
// shares, and sharings represented by (pointer to first share, stride).
//
// In Jasmin, we cannot directly use pointers to stack memory.
// Therefore, to keep it simple for now, we assume memcpy-ed arrays, hence
// fixed size of NSHARES and stride 1..

fn masked_xor(reg ptr u32[NSHARES] a b c) -> reg ptr u32[NSHARES] {
    reg u32 ta tb tc;
    inline int i;
    for i = 0 to NSHARES {
        ta = a[i];
        tb = b[i];
        tc = ta ^ tb;
        c[i] = tc;
    }
    return c;
}

inline fn masked_not(reg ptr u32[NSHARES] x) -> reg ptr u32[NSHARES] {
    reg u32 t;
    t = x[0];
    t = !t;
    x[0] = t;
    return x;
}

// Utility for masked_and
inline fn pini_and_core(reg u32 a b r) -> reg u32 {
    reg u32 temp s;
    temp = b ^ r;
    temp &= a;
    //s = r & !a;
    s = #BIC(r, a);
    s = s ^ temp;
    return s;
}

fn rnd_u32() -> reg u32 {
    stack u8[4] r;
    reg u32 s;
    r = #randombytes(r);
    s = r[u32 0];
    //s = 0;
    return s;
}

fn masked_and(reg ptr u32[NSHARES] a b c) -> reg ptr u32[NSHARES] {
    reg u32 i j r r2 t t2 ta tb;
    i = 0;
    while (i < NSHARES) {
        ta = a[(int) i];
        tb = b[(int) i];
        t = ta & tb;
        c[(int) i] = t;
        i += 1;
    }
    i = 0;
    while (i < NSHARES) {
        j = i;
        j = j+1;
        while (j < NSHARES) {
            r = rnd_u32();
            r2 = r;

            t = c[(int) i];
            ta = a[(int) i];
            tb = b[(int) j];
            t2 = pini_and_core(ta, tb, r2);
            t ^= t2;
            c[(int) i] = t;

            t = c[(int) j];
            ta = a[(int) j];
            tb = b[(int) i];
            t2 = pini_and_core(ta, tb, r);
            t ^= t2;
            c[(int) j] = t;

            j += 1;
        }
        i += 1;
    }
    return c;
}


// Unmasked 64-bit Bitslice masked value.
inline fn unmask_boolean(reg ptr u32[NSHARES] x) -> reg u32 {
    reg u32 res;
    inline int i;
    res = 0;
    for i = 0 to NSHARES {
        reg u32 y;
        y = x[i];
        res ^= y;
    }
    return res;
}

fn extract_sharing_row(reg ptr u32[MROW] state, reg u32 offset, reg ptr u32[NSHARES] res) -> reg ptr u32[NSHARES] {
    reg u32 t;
    inline int i;
    for i = 0 to NSHARES {
        reg u32 addr;
        addr = offset + i * ROW;
        t = state[(int) addr];
        res[i] = t;
    }
    return res;
}

fn extract_sharing(reg ptr u32[MSTATE] state, reg u32 offset, reg ptr u32[NSHARES] res) -> reg ptr u32[NSHARES] {
    reg u32 t;
    inline int i;
    for i = 0 to NSHARES {
        reg u32 addr;
        addr = offset + i * STATE;
        t = state[(int) addr];
        res[i] = t;
    }
    return res;
}

inline fn insert_sharing(reg ptr u32[MSTATE] state, reg ptr u32[NSHARES] sharing, reg u32 offset) -> reg ptr u32[MSTATE] {
    reg u32 t;
    inline int i;
    for i = 0 to NSHARES {
        t = sharing[i];
        state[(int) offset] = t;
        offset += STATE;
    }
    return state;
}

