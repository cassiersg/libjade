from Jade require "common/keccak/keccak1600/amd64/spec/keccakf1600_globals.jinc" // KECCAK1600_RC

require "masked_constants.jinc"
require "gadgets.jinc"

inline fn __index_spec(inline int x y) -> inline int
{
  inline int r;
  r = (x % 5) + 5 * (y % 5);
  return r;
}


inline fn __keccak_rho_offsets_spec(inline int i) -> inline int
{
  inline int r x y z t;

  r = 0;
  x = 1;
  y = 0;

  for t = 0 to 24 {
    if (i == x + 5 * y) {
      r = ((t + 1) * (t + 2) / 2) % 64;
    }
    z = (2 * x + 3 * y) % 5;
    x = y;
    y = z;
  }

  return r;
}


inline fn __rhotates_spec(inline int x y) -> inline int
{
  inline int i r;
  i = __index_spec(x, y);
  r = __keccak_rho_offsets_spec(i);
  return r;
}


inline fn __theta_spec(stack u64[25] a) -> stack u64[25]
{
  inline int x y;
  reg u64[5] c d;

  for x = 0 to 5 {
    c[x] = 0;
    for y = 0 to 5 {
      c[x] ^= a[x + 5 * y];
    }
  }

  for x = 0 to 5 {
    d[x] = c[(x + 1) % 5];
    _, _, d[x] = #ROL_64(d[x], 1);
    d[x] ^= c[(x + 4) % 5];
  }

  for x = 0 to 5 {
    for y = 0 to 5 {
      a[x + 5 * y] ^= d[x];
    }
  }

  return a;
}


inline fn __rho_spec(stack u64[25] a) -> stack u64[25]
{
  inline int x y i z;

  for x = 0 to 5 {
    for y = 0 to 5 {
      i = __index_spec(x, y);
      z = __keccak_rho_offsets_spec(i);
      _, _, a[i] = #ROL_64(a[i], z);
    }
  }

  return a;
}


inline fn __pi_spec(stack u64[25] a) -> stack u64[25]
{
  inline int x y i;
  stack u64[25] b;
  reg u64 t;

  for i = 0 to 25
  { t = a[i]; b[i] = t; }

  for x = 0 to 5 {
    for y = 0 to 5 {
      t = b[x + 5 * y];
      i = __index_spec(y, 2 * x + 3 * y);
      a[i] = t;
    }
  }
  return a;
}


inline fn __chi_spec(stack u64[25] a) -> stack u64[25]
{
  inline int x y i;
  reg u64[5] c;

  for y = 0 to 5 {
    for x = 0 to 5 {
      i = __index_spec(x + 1, y);
      c[x] = a[i];
      c[x] = !c[x];
      i = __index_spec(x + 2, y);
      c[x] &= a[i];
      i = __index_spec(x, y);
      c[x] ^= a[i];
    }
    for x = 0 to 5 {
      a[x + 5 * y] = c[x];
    }
  }
  return a;
}

inline fn new_array(reg u64 x) -> stack u64[NSHARES] {
    stack u64[NSHARES] res;
    inline int i;
    for i = 0 to NSHARES {
        res[i] = x;
    }
    return res;
}

fn __masked_chi_spec(reg ptr u64[MSTATE] a) -> reg ptr u64[MSTATE]
{
    inline int x y i;
    stack u64[NSHARES*5] c;
    stack u64[NSHARES] t t2 t3;
    reg u64 z;
    reg u64 ir;
    ?{}, z = #set0();

    for y = 0 to 5 {
        for x = 0 to 5 {
            i = __index_spec(x + 1, y);
            ir = i;
            t = extract_sharing(a, ir, t);
            t = masked_not(t);
            i = __index_spec(x + 2, y);
            ir = i;
            t2 = extract_sharing(a, ir, t2);
            t3 = masked_and(t, t2, t3);
            i = __index_spec(x, y);
            ir = i;
            t2 = extract_sharing(a, ir, t2);
            t = masked_xor(t3, t2, t);
            for i = 0 to NSHARES {
                c[x + i * 5] = t[i];
            }
        }
        for x = 0 to 5 {
            for i = 0 to NSHARES {
                a[x + 5 * y + i * STATE] = c[x + i * 5];
            }
        }
    }
    return a;
}


inline fn __iota_spec(stack u64[25] a, reg u64 c) -> stack u64[25]
{
  a[0] ^= c;
  return a;
}

inline fn __extract_keccack_share(stack u64[MSTATE] state, inline int sh_idx) -> stack u64[STATE] {
    inline int i;
    stack u64[STATE] res;
    for i = 0 to STATE {
        res[i] = state[STATE * sh_idx + i];
    }
    return res;
}

inline fn __update_keccack_state(stack u64[MSTATE] state, stack u64[STATE] sh_state, inline int sh_idx) -> stack u64[MSTATE] {
    inline int i;
    for i = 0 to STATE {
        state[STATE * sh_idx + i] = sh_state[i];
    }
    return state;
}

inline fn get_rc(stack u64 round) -> reg u64 {
  reg ptr u64[24] kRCp;
  reg u64 RC round_r;
  round_r = round;
  kRCp = KECCAK1600_RC;
  RC = kRCp[(int) round_r];
  return RC;
}

inline fn __keccakP1600_round_spec(stack u64[MSTATE] state, stack u64 round) -> stack u64[MSTATE]
{
    inline int i;
    stack u64[STATE] sh_state;
    for i = 0 to NSHARES {
        // TODO replace this with array indexing.
        sh_state = __extract_keccack_share(state, i);
        sh_state = __theta_spec(sh_state);
        sh_state = __rho_spec(sh_state);
        sh_state = __pi_spec(sh_state);
        state = __update_keccack_state(state, sh_state, i);
    }
    state = __masked_chi_spec(state);
    sh_state = __extract_keccack_share(state, 0);
    reg u64 RC;
    RC = get_rc(round);
    sh_state = __iota_spec(sh_state, RC);
    state = __update_keccack_state(state, sh_state, 0);
  return state;
}


inline fn masked_keccakf1600(stack u64[MSTATE] state) -> stack u64[MSTATE]
{
    stack u64 round;
    round = 0;
    while(round < 24)
    {
        state = __keccakP1600_round_spec(state, round);
        round += 1;
    }
    return state;
}

fn __refresh_state(reg ptr u64[MSTATE] state) -> reg ptr u64[MSTATE] {
    reg u64 i s;
    s = STATE;
    i = 0;
    while (i < 25) {
        reg u64 j;
        j = STATE;
        while (j < MSTATE) {
            reg u64 r off;
            r = rnd_u64();
            off = j;
            off += i;
            state[(int) i] ^= r;
            state[(int) off] ^= r;
            j += s;
        }
        i += 1;
    }
    return state;
}
fn __unmask_state(reg ptr u64[MSTATE] state) -> reg ptr u64[MSTATE] {
    reg u64 i s;
    s = STATE;
    i = 0;
    while (i < 25) {
        reg u64 j;
        j = STATE;
        while (j < MSTATE) {
            reg u64 x off;
            off = j;
            off += i;
            x = state[(int) off];
            state[(int) off] = 0;
            state[(int) i] ^= x;
            j += s;
        }
        i += 1;
    }
    return state;
}


inline fn __keccakf1600_ref(stack u64[25] a) -> stack u64[25] {
    inline int i;
    stack u64[MSTATE] b;
    for i = 0 to MSTATE {
        b[i] = 0;
    }
    for i = 0 to 25 {
        b[i] = a[i];
    }
    b = __refresh_state(b);
    b = masked_keccakf1600(b);
    b = __unmask_state(b);
    for i = 0 to 25 {
        a[i] = b[i];
    }
    return a;
}
